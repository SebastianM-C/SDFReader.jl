var documenterSearchIndex = {"docs":
[{"location":"#SDFReader.jl","page":"SDFReader.jl","title":"SDFReader.jl","text":"","category":"section"},{"location":"","page":"SDFReader.jl","title":"SDFReader.jl","text":"","category":"page"},{"location":"","page":"SDFReader.jl","title":"SDFReader.jl","text":"Modules = [SDFReader]","category":"page"},{"location":"#SDFReader.PlainMeshBlockHeader","page":"SDFReader.jl","title":"SDFReader.PlainMeshBlockHeader","text":"PlainMeshBlockHeader{T,N}\n\nA mesh defines the locations at which variables are defined. Since the geometry of a problem is fixed and most variables will be defined at positions relative to a fixed grid, it makes sense to write this position data once in its own block. Each variable will then refer to one of these mesh blocks to provide their location data.\n\nThe PlainMeshBlockHeader is used for representing the positions at which scalar field discretizations are defined. The block header contains the base_header (a BlockHeader) and the following metadata\n\nmults: The normalisation factor applied to the grid data\n\nin each direction.\n\nlabels: The axis labels for this grid in each direction.\nunits: The units for this grid in each direction after the\n\nnormalisation factors have been applied.\n\ngeometry: The geometry of the block.\nminval: The minimum coordinate values in each direction.\nmaxval: The maximum coordinate values in each direction.\n\nThe geometry of the block can take the following values\n\nNull: Unspecified geometry. This is an error.\nCartesian: Cartesian geometry.\nCylindrical: Cylindrical geometry.\nSpherical: Spherical geometry.\n\nThe last item in the header is dims, is the number of grid points in each dimension.\n\nThe data written is the locations of node points for the mesh in each of the simulation dimensions. Therefore for a 3d simulation of resolution (nx ny nz), the data will consist of a 1d array of X positions with (nx + 1) elements followed by a 1d array of Y positions with (ny + 1) elements and finally a 1d array of Z positions with (nz + 1) elements. Here the resolution specifies the number of simulation cells and therefore the nodal values have one extra element. In a 1d or 2d simulation, you would write only the X or X and Y arrays respectively.\n\n\n\n\n\n","category":"type"},{"location":"#SDFReader.PlainVariableBlockHeader","page":"SDFReader.jl","title":"SDFReader.PlainVariableBlockHeader","text":"PlainVariableBlockHeader{T,N}\n\nThe PlainVariableBlockHeader is used to describe a variable which is located relative to the points given in a mesh block.\n\nThe block header contains the base_header (a BlockHeader) and the following metadata\n\nmult: The normalisation factor applied to the variable data.\nunits: The units for this variable after the normalisation factor has\n\nbeen applied.\n\nmesh_id: The name(id) of the mesh relative to which this block's data is defined.\ndims: The number of grid points in each dimension.\nstagger: The location of the variable relative to its associated mesh.\n\nThe mesh associated with a variable is always node-centred, i.e. the values written as mesh data specify the nodal values of a grid. Variables may be defined at points which are offset from this grid due to grid staggering in the code. The stagger entry specifies where the variable is defined relative to the mesh. Since we have already defined the number of points that the associated mesh contains, this determines how many points are required to display the variable.\n\nThe stagger entry can take one of the following values\n\nCellCentre: Cell centred. At the midpoint between nodes. Implies an\n\n(nx ny nz) grid.\n\nFaceX: Face centred in X. Located at the midpoint between nodes on\n\nthe Y-Z plane. Implies an (nx + 1 ny nz) grid.\n\nFaceY: Face centred in Y. Located at the midpoint between nodes on\n\nthe X-Z plane. Implies an (nx ny + 1 nz) grid.\n\nFaceZ: Face centred in Z. Located at the midpoint between nodes on\n\nthe X-Y plane. Implies an (nx ny nz + 1) grid.\n\nEdgeX: Edge centred along X. Located at the midpoint between nodes\n\nalong the X-axis. Implies an (nx ny + 1 nz + 1) grid.\n\nEdgeY: Edge centred along Y. Located at the midpoint between nodes\n\nalong the Y-axis. Implies an (nx + 1 ny nz + 1) grid.\n\nEdgeZ: Edge centred along Z. Located at the midpoint between nodes\n\nalong the Z-axis. Implies an (nx + 1 ny + 1 nz) grid.\n\nVertex: Node centred. At the same place as the mesh. Implies an ``(nx+\n\n1; ny + 1; nz + 1)`` grid.\n\nFor a grid based variable, the data written contains the values of the given variable at each point on the mesh. This is in the form of a 1d, 2d or 3d array depending on the dimensions of the simulation. The size of the array depends on the size of the associated mesh and the grid staggering as indicated above. It corresponds to the values written into the dims array written for this block.\n\n\n\n\n\n","category":"type"},{"location":"#SDFReader.PointMeshBlockHeader","page":"SDFReader.jl","title":"SDFReader.PointMeshBlockHeader","text":"PointMeshBlockHeader{T,N}\n\nA mesh defines the locations at which variables are defined. Since the geometry of a problem is fixed and most variables will be defined at positions relative to a fixed grid, it makes sense to write this position data once in its own block. Each variable will then refer to one of these mesh blocks to provide their location data.\n\nThe PointMeshBlockHeader is used for representing the positions at which vector field discretizations are defined. The block header contains the base_header (a BlockHeader) and the following metadata\n\nmults: The normalisation factor applied to the grid data\n\nin each direction.\n\nlabels: The axis labels for this grid in each direction.\nunits: The units for this grid in each direction after the\n\nnormalisation factors have been applied.\n\ngeometry: The geometry of the block.\nminval: The minimum coordinate values in each direction.\nmaxval: The maximum coordinate values in each direction.\nnp: The number of points.\n\nThe geometry of the block can take the following values\n\nNull: Unspecified geometry. This is an error.\nCartesian: Cartesian geometry.\nCylindrical: Cylindrical geometry.\nSpherical: Spherical geometry.\n\nThe data written is the locations of each point in the first direction followed by the locations in the second direction and so on. Thus, for a 3d simulation, if we define the first point as having coordinates (x_1 y_1 x_1) and the second point as (x_2 y_2 z_2), etc. then the data written to file is a 1d array with  elements (x_1 x_2 dots x_np), followed by the array (y_1 y_2 dots y_np) and finally the array (z_1 z_2 dots z_np) where np corresponds to the number of points in the mesh. For a 1d simulation, only the x array is written and for a 2d simulation only the x and y arrays are written.\n\n\n\n\n\n","category":"type"},{"location":"#SDFReader.PointVariableBlockHeader","page":"SDFReader.jl","title":"SDFReader.PointVariableBlockHeader","text":"PointVariableBlockHeader{T,N}\n\nThe PointVariableBlockHeader is used to describe a variable which is located relative to the points given in a mesh block.\n\nThe block header contains the base_header (a BlockHeader) and the following metadata\n\nmult: The normalisation factor applied to the variable data.\nunits: The units for this variable after the normalisation factor has\n\nbeen applied.\n\nmesh_id: The name(id) of the mesh relative to which this block's data is defined.\nnp: The number of points.\n\nSimilarly to the grid based variable, the data written contains the values of the given variable at each point on the mesh. Since each the location of each point in space is known fully, there is no need for a stagger variable. The data is in the form of a 1d array with np elements.\n\n\n\n\n\n","category":"type"}]
}
