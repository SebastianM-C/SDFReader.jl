<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SDFReader.jl · SDFReader</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SDFReader</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SDFReader.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SDFReader.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SDFReader.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SebastianM-C/SDFReader.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SDFReader.jl"><a class="docs-heading-anchor" href="#SDFReader.jl">SDFReader.jl</a><a id="SDFReader.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SDFReader.jl" title="Permalink"></a></h1><ul><li><a href="#SDFReader.PlainMeshBlockHeader"><code>SDFReader.PlainMeshBlockHeader</code></a></li><li><a href="#SDFReader.PlainVariableBlockHeader"><code>SDFReader.PlainVariableBlockHeader</code></a></li><li><a href="#SDFReader.PointMeshBlockHeader"><code>SDFReader.PointMeshBlockHeader</code></a></li><li><a href="#SDFReader.PointVariableBlockHeader"><code>SDFReader.PointVariableBlockHeader</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SDFReader.PlainMeshBlockHeader" href="#SDFReader.PlainMeshBlockHeader"><code>SDFReader.PlainMeshBlockHeader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PlainMeshBlockHeader{T,N}</code></pre><p>A mesh defines the locations at which variables are defined. Since the geometry of a problem is fixed and most variables will be defined at positions relative to a fixed grid, it makes sense to write this position data once in its own block. Each variable will then refer to one of these mesh blocks to provide their location data.</p><p>The <code>PlainMeshBlockHeader</code> is used for representing the positions at which scalar field discretizations are defined. The block header contains the <code>base_header</code> (a <code>BlockHeader</code>) and the following metadata</p><ul><li><code>mults</code>: The normalisation factor applied to the grid data</li></ul><p>in each direction.</p><ul><li><code>labels</code>: The axis labels for this grid in each direction.</li><li><code>units</code>: The units for this grid in each direction after the</li></ul><p>normalisation factors have been applied.</p><ul><li><code>geometry</code>: The geometry of the block.</li><li><code>minval</code>: The minimum coordinate values in each direction.</li><li><code>maxval</code>: The maximum coordinate values in each direction.</li></ul><p>The geometry of the block can take the following values</p><ul><li><code>Null</code>: Unspecified geometry. This is an error.</li><li><code>Cartesian</code>: Cartesian geometry.</li><li><code>Cylindrical</code>: Cylindrical geometry.</li><li><code>Spherical</code>: Spherical geometry.</li></ul><p>The last item in the header is <code>dims</code>, is the number of grid points in each dimension.</p><p>The data written is the locations of node points for the mesh in each of the simulation dimensions. Therefore for a 3d simulation of resolution <span>$(nx; ny; nz)$</span>, the data will consist of a 1d array of X positions with <span>$(nx + 1)$</span> elements followed by a 1d array of Y positions with <span>$(ny + 1)$</span> elements and finally a 1d array of Z positions with <span>$(nz + 1)$</span> elements. Here the resolution specifies the number of simulation cells and therefore the nodal values have one extra element. In a 1d or 2d simulation, you would write only the X or X and Y arrays respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebastianM-C/SDFReader.jl/blob/284d1ed872c53e3b48550af38ce385dc36374d2a/src/sdf_header.jl#L75-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SDFReader.PlainVariableBlockHeader" href="#SDFReader.PlainVariableBlockHeader"><code>SDFReader.PlainVariableBlockHeader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PlainVariableBlockHeader{T,N}</code></pre><p>The <code>PlainVariableBlockHeader</code> is used to describe a variable which is located relative to the points given in a mesh block.</p><p>The block header contains the <code>base_header</code> (a <code>BlockHeader</code>) and the following metadata</p><ul><li><code>mult</code>: The normalisation factor applied to the variable data.</li><li><code>units</code>: The units for this variable after the normalisation factor has</li></ul><p>been applied.</p><ul><li><code>mesh_id</code>: The name(<code>id</code>) of the mesh relative to which this block&#39;s data is defined.</li><li><code>dims</code>: The number of grid points in each dimension.</li><li><code>stagger</code>: The location of the variable relative to its associated mesh.</li></ul><p>The mesh associated with a variable is always node-centred, i.e. the values written as mesh data specify the nodal values of a grid. Variables may be defined at points which are offset from this grid due to grid staggering in the code. The <code>stagger</code> entry specifies where the variable is defined relative to the mesh. Since we have already defined the number of points that the associated mesh contains, this determines how many points are required to display the variable.</p><p>The <code>stagger</code> entry can take one of the following values</p><ul><li><code>CellCentre</code>: Cell centred. At the midpoint between nodes. Implies an</li></ul><p><span>$(nx; ny; nz)$</span> grid.</p><ul><li><code>FaceX</code>: Face centred in X. Located at the midpoint between nodes on</li></ul><p>the Y-Z plane. Implies an <span>$(nx + 1; ny; nz)$</span> grid.</p><ul><li><code>FaceY</code>: Face centred in Y. Located at the midpoint between nodes on</li></ul><p>the X-Z plane. Implies an <span>$(nx; ny + 1; nz)$</span> grid.</p><ul><li><code>FaceZ</code>: Face centred in Z. Located at the midpoint between nodes on</li></ul><p>the X-Y plane. Implies an <span>$(nx; ny; nz + 1)$</span> grid.</p><ul><li><code>EdgeX</code>: Edge centred along X. Located at the midpoint between nodes</li></ul><p>along the X-axis. Implies an <span>$(nx; ny + 1; nz + 1)$</span> grid.</p><ul><li><code>EdgeY</code>: Edge centred along Y. Located at the midpoint between nodes</li></ul><p>along the Y-axis. Implies an <span>$(nx + 1; ny; nz + 1)$</span> grid.</p><ul><li><code>EdgeZ</code>: Edge centred along Z. Located at the midpoint between nodes</li></ul><p>along the Z-axis. Implies an <span>$(nx + 1; ny + 1; nz)$</span> grid.</p><ul><li><code>Vertex</code>: Node centred. At the same place as the mesh. Implies an ``(nx+</li></ul><p>1; ny + 1; nz + 1)`` grid.</p><p>For a grid based variable, the data written contains the values of the given variable at each point on the mesh. This is in the form of a 1d, 2d or 3d array depending on the dimensions of the simulation. The size of the array depends on the size of the associated mesh and the grid staggering as indicated above. It corresponds to the values written into the <code>dims</code> array written for this block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebastianM-C/SDFReader.jl/blob/284d1ed872c53e3b48550af38ce385dc36374d2a/src/sdf_header.jl#L189-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SDFReader.PointMeshBlockHeader" href="#SDFReader.PointMeshBlockHeader"><code>SDFReader.PointMeshBlockHeader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointMeshBlockHeader{T,N}</code></pre><p>A mesh defines the locations at which variables are defined. Since the geometry of a problem is fixed and most variables will be defined at positions relative to a fixed grid, it makes sense to write this position data once in its own block. Each variable will then refer to one of these mesh blocks to provide their location data.</p><p>The <code>PointMeshBlockHeader</code> is used for representing the positions at which vector field discretizations are defined. The block header contains the <code>base_header</code> (a <code>BlockHeader</code>) and the following metadata</p><ul><li><code>mults</code>: The normalisation factor applied to the grid data</li></ul><p>in each direction.</p><ul><li><code>labels</code>: The axis labels for this grid in each direction.</li><li><code>units</code>: The units for this grid in each direction after the</li></ul><p>normalisation factors have been applied.</p><ul><li><code>geometry</code>: The geometry of the block.</li><li><code>minval</code>: The minimum coordinate values in each direction.</li><li><code>maxval</code>: The maximum coordinate values in each direction.</li><li><code>np</code>: The number of points.</li></ul><p>The geometry of the block can take the following values</p><ul><li><code>Null</code>: Unspecified geometry. This is an error.</li><li><code>Cartesian</code>: Cartesian geometry.</li><li><code>Cylindrical</code>: Cylindrical geometry.</li><li><code>Spherical</code>: Spherical geometry.</li></ul><p>The data written is the locations of each point in the first direction followed by the locations in the second direction and so on. Thus, for a 3d simulation, if we define the first point as having coordinates <span>$(x_1; y_1; x_1)$</span> and the second point as <span>$(x_2; y_2; z_2)$</span>, etc. then the data written to file is a 1d array with  elements <span>$(x_1; x_2; \dots; x_{np})$</span>, followed by the array <span>$(y_1; y_2; \dots; y_{np})$</span> and finally the array <span>$(z_1; z_2; \dots; z_{np})$</span> where <span>$np$</span> corresponds to the number of points in the mesh. For a 1d simulation, only the x array is written and for a 2d simulation only the x and y arrays are written.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebastianM-C/SDFReader.jl/blob/284d1ed872c53e3b48550af38ce385dc36374d2a/src/sdf_header.jl#L127-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SDFReader.PointVariableBlockHeader" href="#SDFReader.PointVariableBlockHeader"><code>SDFReader.PointVariableBlockHeader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointVariableBlockHeader{T,N}</code></pre><p>The <code>PointVariableBlockHeader</code> is used to describe a variable which is located relative to the points given in a mesh block.</p><p>The block header contains the <code>base_header</code> (a <code>BlockHeader</code>) and the following metadata</p><ul><li><code>mult</code>: The normalisation factor applied to the variable data.</li><li><code>units</code>: The units for this variable after the normalisation factor has</li></ul><p>been applied.</p><ul><li><code>mesh_id</code>: The name(<code>id</code>) of the mesh relative to which this block&#39;s data is defined.</li><li><code>np</code>: The number of points.</li></ul><p>Similarly to the grid based variable, the data written contains the values of the given variable at each point on the mesh. Since each the location of each point in space is known fully, there is no need for a stagger variable. The data is in the form of a 1d array with <code>np</code> elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SebastianM-C/SDFReader.jl/blob/284d1ed872c53e3b48550af38ce385dc36374d2a/src/sdf_header.jl#L246-L263">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 12 May 2021 14:33">Wednesday 12 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
